
/* 
#Digite en PowerShell para conocer el Container ID 
docker ps

#Mi Container ID:b3712b100de8
#Cargamos los csv en el contenedor digitando lo siguiente en powershell
docker cp "C:\Users\Mauricio Serrano\OneDrive - Universidad de Costa Rica\Github\Investigacion-Grupal-1\Agencias.csv" b3712b100de8:/var/lib/memgraph/
docker cp "C:\Users\Mauricio Serrano\OneDrive - Universidad de Costa Rica\Github\Investigacion-Grupal-1\LineasDeTransmision.csv" b3712b100de8:/var/lib/memgraph/
docker cp "C:\Users\Mauricio Serrano\OneDrive - Universidad de Costa Rica\Github\Investigacion-Grupal-1\Subestaciones.csv" b3712b100de8:/var/lib/memgraph/

#ingresamos al entorno de Memgraph
docker exec -it b3712b100de8 bash
*/

/*Cargamos las bases de datos en Cypher editor*/
/*Creamos nodos Subestaciones*/
LOAD CSV FROM "/var/lib/memgraph/Agencias.csv" WITH HEADER AS row
CREATE (:Agencia {
    id: toInteger(row.OBJECTID_1),
    nombre: row.Nombre,
    direccion: row.Direccion,
    telefono: row.Telefono,
    fax: row.Fax,
    horario: row.Horario,
    x: toFloat(row.x),
    y: toFloat(row.y)
});

LOAD CSV FROM "/var/lib/memgraph/Subestaciones.csv" WITH HEADER AS row
CREATE (:Subestacion {
    id: toInteger(row.OBJECTID),
    nombre: row.Subestacio,
    provincia: row.Provincia,
    canton: row.Canton,
    distrito: row.Distrito,
    x: toFloat(row.PuntoX),
    y: toFloat(row.PuntoY)
});

/*Creamos las relaciones usando el CSV LineasDeTransmision*/
/*Esto crea relaciones (:Subestacion)-[:LINEA]->(:Subestacion)  */
LOAD CSV FROM "/var/lib/memgraph/LineasDeTransmision.csv" WITH HEADER AS row
MATCH (a:Subestacion {nombre: SPLIT(row.Circuito, "-")[0]}),
      (b:Subestacion {nombre: SPLIT(row.Circuito, "-")[1]})
CREATE (a)-[:LINEA {
    voltaje: toInteger(row.Voltaje),
    longitud: toFloat(row.Shape__Length),
    peso: Round(toFloat(row.Shape__Length) * 10) / 10 /1000  // <-- Peso con un decimal, expresado en KM
}]->(b);


//Numero de conexiones que tiene cada estacion
MATCH (s:Subestacion)
OPTIONAL MATCH (s)-[:LINEA]->()
WITH s, count(*) AS out_deg
OPTIONAL MATCH (s)<-[:LINEA]-()
WITH s, out_deg, count(*) AS in_deg
RETURN s.nombre AS subestacion,
       out_deg  AS salientes,
       in_deg   AS entrantes,
       (out_deg + in_deg) AS total
ORDER BY total DESC, subestacion;

// Subestacion mas conectada
MATCH (s:Subestacion)
OPTIONAL MATCH (s)-[:LINEA]->()
WITH s, count(*) AS out_deg
OPTIONAL MATCH (s)<-[:LINEA]-()
WITH s, out_deg, count(*) AS in_deg
RETURN s.nombre AS subestacion,
       out_deg + in_deg AS total
ORDER BY total DESC
LIMIT 1;

// Distancia mas corta entre las Subestaciones <---Corregido
MATCH (a:Subestacion)-[l:LINEA]-(b:Subestacion)
WITH a, b, l
ORDER BY a.nombre, l.peso ASC
WITH a, collect({
  vecino: b.nombre,
  km_red: toInteger(round(l.peso))
})[0] AS mejor
RETURN a.nombre AS estacion,
       mejor.vecino AS vecino_mas_cercano,
       mejor.km_red AS distancia_km
ORDER BY distancia_km ASC;

// Distancia promedio por estacion:
MATCH (s:Subestacion)-[r:LINEA]-()
WITH s, avg(r.peso) AS avg_km
RETURN s.nombre AS subestacion,
       round(avg_km*1)/1.0 AS km_promedio
ORDER BY km_promedio DESC, subestacion;

/*Visualizar el grafo */
MATCH (n)-[r:LINEA]->(m)
RETURN n, r, m;


/*Para borrar los nodos y evitar que aparezcan repetidos*/
/*MATCH (n)
DETACH DELETE n; */


