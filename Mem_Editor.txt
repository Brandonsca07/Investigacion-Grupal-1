
/* 
#Digite en PowerShell para conocer el Container ID 
docker ps

#Mi Container ID:b3712b100de8
#Cargamos los csv en el contenedor digitando lo siguiente en powershell
docker cp "C:\Users\Mauricio Serrano\OneDrive - Universidad de Costa Rica\Github\Investigacion-Grupal-1\Agencias.csv" b3712b100de8:/var/lib/memgraph/
docker cp "C:\Users\Mauricio Serrano\OneDrive - Universidad de Costa Rica\Github\Investigacion-Grupal-1\LineasDeTransmision.csv" b3712b100de8:/var/lib/memgraph/
docker cp "C:\Users\Mauricio Serrano\OneDrive - Universidad de Costa Rica\Github\Investigacion-Grupal-1\Subestaciones.csv" b3712b100de8:/var/lib/memgraph/

#ingresamos al entorno de Memgraph
docker exec -it b3712b100de8 bash
*/

/*Cargamos las bases de datos en Cypher editor*/
/*Creamos nodos con Agencias y Subestaciones*/
LOAD CSV FROM "/var/lib/memgraph/Agencias.csv" WITH HEADER AS row
CREATE (:Agencia {
    id: toInteger(row.OBJECTID_1),
    nombre: row.Nombre,
    direccion: row.Direccion,
    telefono: row.Telefono,
    fax: row.Fax,
    horario: row.Horario,
    x: toFloat(row.x),
    y: toFloat(row.y)
});

LOAD CSV FROM "/var/lib/memgraph/Subestaciones.csv" WITH HEADER AS row
CREATE (:Subestacion {
    id: toInteger(row.OBJECTID),
    nombre: row.Subestacio,
    provincia: row.Provincia,
    canton: row.Canton,
    distrito: row.Distrito,
    x: toFloat(row.PuntoX),
    y: toFloat(row.PuntoY)
});

/*Creamos las relaciones usando el CSV LineasDeTransmision*/
/*Esto crea relaciones (:Subestacion)-[:LINEA]->(:Subestacion)  */
LOAD CSV FROM "/var/lib/memgraph/LineasDeTransmision.csv" WITH HEADER AS row
MATCH (a:Subestacion {nombre: SPLIT(row.Circuito, "-")[0]}),
      (b:Subestacion {nombre: SPLIT(row.Circuito, "-")[1]})
CREATE (a)-[:LINEA {
    voltaje: toInteger(row.Voltaje),
    longitud: toFloat(row.Shape__Length),
    peso: Round(toFloat(row.Shape__Length) * 10) / 10 /1000  // <-- Peso con un decimal, expresado en KM
}]->(b);


//Numero de conexiones que tiene cada estacion
MATCH (s:Subestacion)
OPTIONAL MATCH (s)-[:LINEA]->()
WITH s, count(*) AS out_deg
OPTIONAL MATCH (s)<-[:LINEA]-()
WITH s, out_deg, count(*) AS in_deg
RETURN s.nombre AS subestacion,
       out_deg  AS salientes,
       in_deg   AS entrantes,
       (out_deg + in_deg) AS total
ORDER BY total DESC, subestacion;

// Subestacion mas conectada
MATCH (s:Subestacion)
OPTIONAL MATCH (s)-[:LINEA]->()
WITH s, count(*) AS out_deg
OPTIONAL MATCH (s)<-[:LINEA]-()
WITH s, out_deg, count(*) AS in_deg
RETURN s.nombre AS subestacion,
       out_deg + in_deg AS total
ORDER BY total DESC
LIMIT 1;

// Distancia mas corta entre las Subestaciones 
MATCH (a:Subestacion) <-- este codigo ahora da errores en la salida REVISARLO
WITH a, point({x:a.x, y:a.y}) AS a_loc
MATCH (b:Subestacion)
WITH a, a_loc, b, point({x:b.x, y:b.y}) AS b_loc
WHERE a != b
WITH a, b, point.distance(a_loc, b_loc) / 1000.0 AS km
ORDER BY a.nombre, km
WITH a, collect({b:b, km:km})[0] AS nearest
RETURN a.nombre AS origen,
       nearest.b.nombre AS mas_cercana,
       round(nearest.km * 1) / 1.0 AS km   
ORDER BY origen;

// Distancia promedio por estacion:
MATCH (s:Subestacion)-[r:LINEA]-()
WITH s, avg(r.peso) AS avg_km
RETURN s.nombre AS subestacion,
       round(avg_km*1)/1.0 AS km_promedio
ORDER BY km_promedio DESC, subestacion;

/*Visualizar el grafo */
MATCH (n)-[r:LINEA]->(m)
RETURN n, r, m;


/*Para borrar los nodos y evitar que aparezcan repetidos*/
/*MATCH (n)
DETACH DELETE n; */


